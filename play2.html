<!DOCTYPE html>
<html>
  <head>
    <title>Play2 prototype</title>
    <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
    <style>

body
{
  background: #aaa;
}
#container
{
  width: 600px;
  height: 500px;
  margin: auto;
  background: #eee;
}
#b, #c, #v
{
  image-rendering: optimizeSpeed;
  image-rendering: -moz-crisp-edges;
  image-rendering: -webkit-optimize-contrast;
  image-rendering: optimize-contrast;
  -ms-interpolation-mode: nearest-neighbor;
  width: 600px;
  height: 500px;
  cursor: crosshair;
  position: absolute;
}
#wc {
  position: relative;
  left: 600px;
}
#stuff
{
  display: none;
}

    </style>
  </head>
  <body>
    <div id="container">
      <canvas id="b" width="600" height="500"></canvas>
      <canvas id="c" width="600" height="500">Your browser does not support HTML5 Canvas.</canvas>
      <canvas id="v" width="600" height="500"></canvas>
      <div id="wc">
        <object id="w" type="application/x-wacomtabletplugin" width="100" height="100"></object>
      </div>
    </div>
    <!--x-->
    <!--x-->
    <!--<textarea id="ta"></textarea>-->
    <script>
/*
ta.onkeydown = function(e)
{
  if (e.keyCode == 13)
  {
    e.preventDefault();
    eval(e.target.value);
  }
}
*/

//(function()
{                                                                                      
  "use strict";

  CanvasRenderingContext2D.prototype.vwLineFill = function(x1, y1, x2, y2, w1, w2)
  {
    var dx = (x2 - x1);
    var dy = (y2 - y1);
    w1 /= 2; w2 /= 2; // we only use w1/2 and w2/2 for computations.
    // length of the AB vector
    var length = Math.sqrt(dx*dx + dy*dy);
    if (!length) return; // exit if zero length
    dx /= length; dy /= length;
    var shiftx = - dy * w1; // compute AA1 vector's x
    var shifty =   dx * w1; // compute AA1 vector's y
    var angle = Math.atan2(shifty, shiftx);
    this.beginPath();
    this.moveTo(x1 + shiftx, y1 + shifty);
    this.arc(x1,y1, w1, angle, angle+Math.PI); // draw A1A2
    shiftx = - dy * w2; // compute BB1 vector's x
    shifty =   dx * w2; // compute BB1 vector's y
    this.lineTo(x2 - shiftx, y2 - shifty); // draw A2B1
    this.arc(x2,y2, w2, angle+Math.PI, angle); // draw A1A2    
    this.closePath(); // draw B2A1
    this.fill();
  };

  var wacom = document.getElementById("w");
  var pressureCompensation = 2.5;

  var getPointerType = function()
  {
    return wacom.penAPI && wacom.isWacom ? wacom.penAPI.pointerType : 0;
  };
  var getPressure = function()
  {
    return wacom.penAPI && wacom.isWacom ? wacom.penAPI.pressure * pressureCompensation : 1;
  };
  var get1 = function()
  {
    return 1;
  };

  var theBrush = {size: 5, color: "#000000", color2: "#ffffd9", getPressure: getPressure};
  var stroke =
  {
    points: [],
    addPoint: function(x, y, d)
    {
      this.points.push([x, y, d]);
    },
    draw: function(context)
    {
      if (this.points.length == 0) return;
      if (this.points.length == 1)
      {
        context.beginPath();
        context.arc(this.points[0][0], this.points[0][1], this.points[0][2] / 2, 0, 2 * Math.PI, false);
        context.fill();
      } else {
        // todo: draw whole stroke as one polygon
        /*
        for (var i = 1; i < this.points.length; i++)
        {
          context.vwLineFill(
            this.points[i - 1][0], this.points[i - 1][1],
            this.points[i][0], this.points[i][1],
            this.points[i - 1][2], this.points[i][2]
          );
        }
        */
      }
      this.points.length = 0;
    },
  };
  var WIDTH = 600, HEIGHT = 500;
  var bgCanvas = document.getElementById("b");
  var bgContext = bgCanvas.getContext("2d");
  var drawCanvas = document.getElementById("c");
  var drawContext = drawCanvas.getContext("2d");
  var visCanvas = document.getElementById("v");
  var visContext = visCanvas.getContext("2d");
  var ox, oy, od;
  bgContext.imageSmoothingEnabled = false;
  drawContext.imageSmoothingEnabled = false;
  visContext.imageSmoothingEnabled = false;
  bgContext.fillStyle = "#ffffd9";
  bgContext.fillRect(0, 0, WIDTH, HEIGHT);

  var snapshots = [drawContext.getImageData(0, 0, WIDTH, HEIGHT)];
  var snapshotPosition = 0;

  var saveSnapshot = function()
  {
    snapshots.length = ++snapshotPosition;
    snapshots.push(drawContext.getImageData(0, 0, WIDTH, HEIGHT));
  };
  var undo = function()
  {
    if (snapshotPosition > 0)
    {
      drawContext.putImageData(snapshots[--snapshotPosition], 0, 0);
    }
  };
  var redo = function()
  {
    if (snapshotPosition < snapshots.length - 1)
    {
      drawContext.putImageData(snapshots[++snapshotPosition], 0, 0);
    }
  };
  var canvasMouseMove = function(e)
  {
    if (theBrush.pressed)
    {
      e.preventDefault();
      var x = Math.floor((e.pageX - drawCanvas.offsetLeft));
      var y = Math.floor((e.pageY - drawCanvas.offsetTop));
      var d = theBrush.size * theBrush.getPressure();

      stroke.addPoint(x, y, d);
      drawContext.vwLineFill(ox, oy, x, y, od, d);

      ox = x;
      oy = y;
      od = d;
    }
  };
  var canvasMouseUp = function(e)
  {
    if (e.button == 0 || e.button == 2)
    {
      e.preventDefault();
      stroke.draw(drawContext);
      theBrush.pressed = 0;

      document.onmousemove = undefined;
      document.onmouseup = undefined;

      saveSnapshot();
    }
  };

  visCanvas.onmousedown = function(e)
  {
    if (e.button == 0 || e.button == 2)
    {
      e.preventDefault();
      theBrush.pressed = 1;
      var x = Math.floor((e.offsetX || e.layerX || 0));
      var y = Math.floor((e.offsetY || e.layerY || 0));
      var pointerType = getPointerType();
      console.log(pointerType);
      theBrush.getPressure = pointerType > 0 ? getPressure : get1;
      drawContext.globalCompositeOperation = pointerType == 3 ? "destination-out" : "source-over";
      drawContext.fillStyle = e.button == 0 ? theBrush.color : theBrush.color2;
      var d = theBrush.size * theBrush.getPressure();
      stroke.addPoint(x, y, d);
      ox = x;
      oy = y;
      od = d;
      document.onmousemove = canvasMouseMove;
      document.onmouseup = canvasMouseUp;
    }
  };
  var visCanvasDirty = false;
  visCanvas.onmousemove = function(e)
  {
    if (visCanvasDirty)
    {
      visContext.clearRect(0, 0, WIDTH, HEIGHT);
      visCanvasDirty = false;
    }
    if (!theBrush.pressed)
    {
      var x = Math.floor((e.pageX - drawCanvas.offsetLeft));
      var y = Math.floor((e.pageY - drawCanvas.offsetTop));
      visContext.fillStyle = theBrush.color;
      visContext.beginPath();
      visContext.arc(x, y, theBrush.size / 2, 0, 2 * Math.PI, false);
      visContext.fill();
      visCanvasDirty = true;
    }
  };
  window.onkeydown = function(e)
  {
    if (e.keyCode == "S".charCodeAt(0))
    {
      theBrush.smoothing = !theBrush.smoothing;
    }
    if (e.keyCode == "E".charCodeAt(0) && e.shiftKey)
    {
      drawContext.fillStyle = "#ffffd9";
      drawContext.fillRect(0, 0, WIDTH, HEIGHT);
      saveSnapshot();
    }
    if (e.keyCode == "Z".charCodeAt(0) && e.ctrlKey)
    {
      e.preventDefault();
      undo();
    }
    if (e.keyCode == "Y".charCodeAt(0) && e.ctrlKey)
    {
      e.preventDefault();
      redo();
    }
  };
  (function fixPluginGoingAWOL()
  {
    var stupidPlugin = document.getElementById("w");
    window.onblur = function(e)
    {
      document.getElementById("wc").removeChild(stupidPlugin);
    };
    window.onfocus = function(e)
    {
      document.getElementById("wc").appendChild(stupidPlugin);
    };
  })();
}//)();

    </script>
  </body>
</html>
<script>
